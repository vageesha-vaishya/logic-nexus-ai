/**
 * pg_dump-compatible SQL export utility
 * Generates a single .sql file that can be imported using psql -f command
 */

import { escapeStr, formatValue, resolveDataTypeForValue } from './dbExportUtils';

export interface PgDumpOptions {
  includeRls: boolean;
  useInsertFormat: boolean; // true = INSERT, false = COPY (COPY is faster but requires file access)
  includeDropStatements: boolean;
  excludeAuthSchema: boolean;
  excludeStorageSchema: boolean;
}

export const defaultPgDumpOptions: PgDumpOptions = {
  includeRls: false,
  useInsertFormat: true, // INSERT is more portable
  includeDropStatements: false,
  excludeAuthSchema: true,
  excludeStorageSchema: true,
};

/**
 * Generates the header for a pg_dump-compatible SQL file
 */
export const generatePgDumpHeader = (): string => {
  const now = new Date().toISOString();
  return `--
-- PostgreSQL database dump
-- Generated by Lovable Database Export
-- Date: ${now}
--
-- This file can be imported using:
--   psql -h hostname -U username -d database -f this_file.sql
--
-- Or via pgAdmin/DBeaver by executing this SQL file
--

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

BEGIN;

`;
};

/**
 * Generates the footer for the SQL file
 */
export const generatePgDumpFooter = (): string => {
  return `
COMMIT;

--
-- PostgreSQL database dump complete
--
`;
};

/**
 * Generates CREATE SCHEMA statements
 */
export const generateSchemaStatements = (schemas: string[]): string => {
  if (schemas.length === 0) return '';
  
  let sql = `--
-- Schemas
--

`;
  schemas.forEach(schema => {
    if (schema !== 'public') {
      sql += `CREATE SCHEMA IF NOT EXISTS "${schema}";\n`;
    }
  });
  sql += '\n';
  return sql;
};

/**
 * Generates CREATE TYPE statements for enums
 */
export const generateEnumStatements = (enums: Array<{ name: string; labels: string[] }>): string => {
  if (enums.length === 0) return '';
  
  let sql = `--
-- Enum Types
--

`;
  enums.forEach(({ name, labels }) => {
    const labelsList = labels.map(l => `'${escapeStr(l)}'`).join(', ');
    sql += `DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = '${name}') THEN
        CREATE TYPE "${name}" AS ENUM (${labelsList});
    END IF;
END $$;\n\n`;
  });
  return sql;
};

/**
 * Generates CREATE TABLE statement
 */
export const generateCreateTableStatement = (
  schemaName: string,
  tableName: string,
  columns: Array<{
    column_name: string;
    data_type: string;
    is_nullable: boolean;
    column_default: string | null;
    is_primary_key: boolean;
  }>,
  includeDropStatement: boolean = false
): string => {
  let sql = '';
  
  if (includeDropStatement) {
    sql += `DROP TABLE IF EXISTS "${schemaName}"."${tableName}" CASCADE;\n`;
  }
  
  sql += `CREATE TABLE IF NOT EXISTS "${schemaName}"."${tableName}" (\n`;
  
  const columnDefs = columns.map(col => {
    let def = `    "${col.column_name}" ${resolveColumnType(col)}`;
    if (!col.is_nullable) {
      def += ' NOT NULL';
    }
    if (col.column_default) {
      def += ` DEFAULT ${col.column_default}`;
    }
    return def;
  });
  
  sql += columnDefs.join(',\n');
  sql += '\n);\n\n';
  
  return sql;
};

/**
 * Resolves column type for CREATE TABLE statements
 */
const resolveColumnType = (col: any): string => {
  const dt = (col.data_type || '').toString();
  if ((dt === 'character varying' || dt === 'varchar') && col.character_maximum_length) {
    return `${dt}(${col.character_maximum_length})`;
  }
  return dt || 'text';
};

/**
 * Generates INSERT statements for table data
 */
export const generateInsertStatements = (
  schemaName: string,
  tableName: string,
  columns: string[],
  rows: any[],
  typeMap: Record<string, string>
): string => {
  if (rows.length === 0) return '';
  
  let sql = `--
-- Data for table ${schemaName}.${tableName}
--

`;
  
  rows.forEach(row => {
    const values = columns.map(col => {
      const dataType = typeMap[col];
      return formatValue(row[col], dataType);
    });
    
    sql += `INSERT INTO "${schemaName}"."${tableName}" (${columns.map(c => `"${c}"`).join(', ')}) VALUES (${values.join(', ')});\n`;
  });
  
  sql += '\n';
  return sql;
};

/**
 * Generates COPY statements for table data (faster but requires file access)
 */
export const generateCopyStatements = (
  schemaName: string,
  tableName: string,
  columns: string[],
  rows: any[],
  typeMap: Record<string, string>
): string => {
  if (rows.length === 0) return '';
  
  let sql = `--
-- Data for table ${schemaName}.${tableName}
--

COPY "${schemaName}"."${tableName}" (${columns.map(c => `"${c}"`).join(', ')}) FROM stdin;
`;
  
  rows.forEach(row => {
    const values = columns.map(col => {
      const value = row[col];
      if (value === null || value === undefined) return '\\N';
      if (typeof value === 'object') return JSON.stringify(value).replace(/\\/g, '\\\\').replace(/\t/g, '\\t').replace(/\n/g, '\\n');
      return String(value).replace(/\\/g, '\\\\').replace(/\t/g, '\\t').replace(/\n/g, '\\n');
    });
    sql += values.join('\t') + '\n';
  });
  
  sql += '\\.\\n\\n';
  return sql;
};

export const validateDollarQuotes = (sql: string): string[] => {
  const errors: string[] = [];
  if (!sql) return errors;

  let cleaned = sql;

  cleaned = cleaned.replace(/'(?:''|[^'])*'/g, "''");

  cleaned = cleaned.replace(/"(?:\\"|[^"])*"/g, '""');

  cleaned = cleaned.replace(/--.*$/gm, '');

  cleaned = cleaned.replace(/\/\*[\s\S]*?\*\//g, '');

  const matches = cleaned.match(/\$\$/g) || [];
  if (matches.length % 2 !== 0) {
    errors.push('[pg_dump_export] Unbalanced $$ dollar-quoted blocks');
  }
  return errors;
};

export const validateInsertTerminations = (sql: string): string[] => {
  const errors: string[] = [];
  const lines = sql.split('\n');
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;
    if (trimmed.startsWith('INSERT INTO') && !trimmed.endsWith(';')) {
      errors.push('[pg_dump_export] INSERT statement without terminating semicolon');
      break;
    }
  }
  return errors;
};

/**
 * Generates constraint statements (PRIMARY KEY, UNIQUE, FOREIGN KEY)
 */
export const generateConstraintStatements = (
  constraints: Array<{
    schema_name: string;
    table_name: string;
    constraint_name: string;
    constraint_type: string;
    constraint_details: string;
  }>
): string => {
  if (constraints.length === 0) return '';
  
  // Group constraints by type
  const primaryKeys = constraints.filter(c => 
    c.constraint_type?.toUpperCase() === 'PRIMARY KEY' || 
    c.constraint_details?.toUpperCase().startsWith('PRIMARY KEY')
  );
  
  const foreignKeys = constraints.filter(c => 
    c.constraint_type?.toUpperCase() === 'FOREIGN KEY' || 
    c.constraint_details?.toUpperCase().startsWith('FOREIGN KEY')
  );
  
  const uniqueConstraints = constraints.filter(c => 
    c.constraint_type?.toUpperCase() === 'UNIQUE' || 
    c.constraint_details?.toUpperCase().startsWith('UNIQUE')
  );
  
  let sql = '';
  
  if (primaryKeys.length > 0) {
    sql += `--
-- Primary Keys
--

`;
    primaryKeys.forEach(c => {
      if (c.constraint_details?.trim()) {
        sql += `ALTER TABLE "${c.schema_name}"."${c.table_name}" ADD CONSTRAINT "${c.constraint_name}" ${c.constraint_details};\n`;
      }
    });
    sql += '\n';
  }
  
  if (uniqueConstraints.length > 0) {
    sql += `--
-- Unique Constraints
--

`;
    uniqueConstraints.forEach(c => {
      if (c.constraint_details?.trim()) {
        sql += `ALTER TABLE "${c.schema_name}"."${c.table_name}" ADD CONSTRAINT "${c.constraint_name}" ${c.constraint_details};\n`;
      }
    });
    sql += '\n';
  }
  
  if (foreignKeys.length > 0) {
    sql += `--
-- Foreign Keys
--

`;
    foreignKeys.forEach(c => {
      if (c.constraint_details?.trim()) {
        sql += `ALTER TABLE "${c.schema_name}"."${c.table_name}" ADD CONSTRAINT "${c.constraint_name}" ${c.constraint_details};\n`;
      }
    });
    sql += '\n';
  }
  
  return sql;
};

/**
 * Generates index statements
 */
export const generateIndexStatements = (
  indexes: Array<{
    schema_name: string;
    table_name: string;
    index_name: string;
    index_definition: string;
  }>
): string => {
  if (indexes.length === 0) return '';
  
  let sql = `--
-- Indexes
--

`;
  indexes.forEach(idx => {
    if (idx.index_definition?.trim()) {
      sql += `${idx.index_definition};\n`;
    }
  });
  sql += '\n';
  return sql;
};

/**
 * Generates function statements
 */
export const generateFunctionStatements = (
  functions: Array<{
    schema?: string;
    name?: string;
    function_name?: string;
    function_definition?: string;
  }>
): string => {
  if (functions.length === 0) return '';
  
  let sql = `--
-- Functions
--

`;
  functions.forEach(func => {
    const name = func.name || func.function_name;
    const schema = func.schema || 'public';
    const def = func.function_definition;
    
    if (def && name) {
      sql += `-- Function: ${schema}.${name}\n`;
      sql += `${def.trim()}\n\n`;
    }
  });
  return sql;
};

/**
 * Generates trigger statements
 */
export const generateTriggerStatements = (
  triggers: Array<{
    schema_name: string;
    table_name: string;
    trigger_name: string;
    trigger_definition: string;
  }>
): string => {
  if (triggers.length === 0) return '';
  
  let sql = `--
-- Triggers
--

`;
  triggers.forEach(trigger => {
    if (trigger.trigger_definition?.trim()) {
      sql += `${trigger.trigger_definition};\n\n`;
    }
  });
  return sql;
};

/**
 * Generates RLS policy statements
 */
export const generateRlsStatements = (
  tables: Array<{ schema_name: string; table_name: string; rls_enabled: boolean }>,
  policies: Array<{
    schema_name: string;
    table_name: string;
    policy_name: string;
    policy_definition: string;
  }>
): string => {
  let sql = '';
  
  // Enable RLS on tables
  const rlsTables = tables.filter(t => t.rls_enabled);
  if (rlsTables.length > 0) {
    sql += `--
-- Row Level Security
--

`;
    rlsTables.forEach(t => {
      sql += `ALTER TABLE "${t.schema_name}"."${t.table_name}" ENABLE ROW LEVEL SECURITY;\n`;
    });
    sql += '\n';
  }
  
  // Add policies
  if (policies.length > 0) {
    sql += `--
-- RLS Policies
--

`;
    policies.forEach(p => {
      if (p.policy_definition?.trim()) {
        sql += `${p.policy_definition};\n`;
      }
    });
    sql += '\n';
  }
  
  return sql;
};

/**
 * Generates sequence reset statements
 */
export const generateSequenceResetStatements = (
  sequences: Array<{
    schema_name: string;
    sequence_name: string;
    current_value: number;
  }>
): string => {
  if (sequences.length === 0) return '';
  
  let sql = `--
-- Sequence Values
--

`;
  sequences.forEach(seq => {
    sql += `SELECT setval('"${seq.schema_name}"."${seq.sequence_name}"', ${seq.current_value}, true);\n`;
  });
  sql += '\n';
  return sql;
};
